<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animal Crossing Vibe Runner</title>
    <style>
      :root {
        font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        color: #1b4332;
        background-color: #f3fff1;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(circle at top, #dff7d1, #bfe1c5 60%, #99c1b9);
        padding: 1.5rem;
      }

      main.game-wrapper {
        width: min(520px, 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
        background: rgba(255, 255, 255, 0.85);
        padding: 1.25rem;
        border-radius: 1.25rem;
        box-shadow: 0 18px 50px rgba(99, 138, 125, 0.2);
      }

      h1 {
        margin: 0;
        font-size: 1.35rem;
        color: #0f5132;
        letter-spacing: 0.04em;
      }

      canvas {
        width: 100%;
        background: #cfe8a9;
        border-radius: 0.75rem;
        box-shadow: inset 0 0 25px rgba(57, 85, 70, 0.25);
        image-rendering: pixelated;
      }

      .hud {
        width: 100%;
        display: flex;
        justify-content: space-between;
        font-weight: 600;
        color: #1d3557;
      }

      .hint {
        margin: 0;
        font-size: 0.9rem;
        text-align: center;
        color: #3a5a40;
      }
    </style>
  </head>
  <body>
    <main class="game-wrapper">
      <h1>Animal Crossing Vibe Runner</h1>
      <canvas id="gameCanvas"></canvas>
      <section class="hud">
        <div>Score: <span id="scoreValue">0</span></div>
        <div>Best: <span id="bestScoreValue">0</span></div>
      </section>
      <p class="hint">Arrow keys move. Reach the top safely. Press Space to restart after a crash.</p>
    </main>

    <script>
      (function () {
        "use strict";

        var canvas = document.getElementById("gameCanvas");
        var ctx = canvas.getContext("2d");
        var scoreElement = document.getElementById("scoreValue");
        var bestScoreElement = document.getElementById("bestScoreValue");

        var COLS = 9;
        var ROWS = 12;
        var TILE_SIZE = 48;
        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;

        var score = 0;
        var bestScore = parseInt(localStorage.getItem("acvBestScore"), 10) || 0;
        bestScoreElement.textContent = bestScore;

        var playerStart = { row: ROWS - 1, col: Math.floor(COLS / 2) };
        var player = { row: playerStart.row, col: playerStart.col };

        var laneSettings = [
          { row: 1, type: "river", speed: 70, direction: 1 },
          { row: 2, type: "river", speed: 95, direction: -1 },
          { row: 4, type: "road", speed: 85, direction: -1 },
          { row: 5, type: "road", speed: 65, direction: 1 },
          { row: 6, type: "road", speed: 105, direction: 1 },
          { row: 8, type: "field", speed: 60, direction: -1 },
          { row: 9, type: "field", speed: 80, direction: 1 },
        ];

        var movers = [];
        var lastTimestamp = 0;
        var isGameOver = false;

        buildMovers();
        document.addEventListener("keydown", handleKeyDown, false);
        window.requestAnimationFrame(gameLoop);

        function buildMovers() {
          movers = [];
          laneSettings.forEach(function (lane) {
            var count = lane.type === "river" ? 3 : 4;
            var width = lane.type === "river" ? TILE_SIZE * 1.4 : TILE_SIZE * 0.9;
            for (var i = 0; i < count; i += 1) {
              var spacing = canvas.width / count;
              var offset = i * spacing;
              movers.push({
                laneType: lane.type,
                row: lane.row,
                x: offset,
                width: width,
                speed: lane.speed * lane.direction,
                baseSpeed: lane.speed * lane.direction,
                color: lane.type === "river" ? "#8b5e34" : lane.type === "road" ? "#f28482" : "#f4a259",
              });
            }
          });
        }

        function gameLoop(timestamp) {
          if (!lastTimestamp) {
            lastTimestamp = timestamp;
          }
          var delta = (timestamp - lastTimestamp) / 1000;
          lastTimestamp = timestamp;

          if (!isGameOver) {
            updateMovers(delta);
            checkCollisions();
          }

          drawScene();
          window.requestAnimationFrame(gameLoop);
        }

        function updateMovers(deltaTime) {
          movers.forEach(function (mover) {
            mover.x += mover.speed * deltaTime;
            if (mover.speed > 0 && mover.x - mover.width > canvas.width) {
              mover.x = -mover.width;
            } else if (mover.speed < 0 && mover.x + mover.width < 0) {
              mover.x = canvas.width;
            }
          });
        }

        function handleKeyDown(event) {
          if (event.code === "Space" && isGameOver) {
            restartGame();
            return;
          }

          if (isGameOver) {
            return;
          }

          var moved = false;
          switch (event.key) {
            case "ArrowUp":
            case "w":
            case "W":
              if (player.row > 0) {
                player.row -= 1;
                moved = true;
              }
              break;
            case "ArrowDown":
            case "s":
            case "S":
              if (player.row < ROWS - 1) {
                player.row += 1;
                moved = true;
              }
              break;
            case "ArrowLeft":
            case "a":
            case "A":
              if (player.col > 0) {
                player.col -= 1;
                moved = true;
              }
              break;
            case "ArrowRight":
            case "d":
            case "D":
              if (player.col < COLS - 1) {
                player.col += 1;
                moved = true;
              }
              break;
            default:
              break;
          }

          if (moved) {
            event.preventDefault();
            if (player.row === 0) {
              handleGoalReached();
            }
          }
        }

        function handleGoalReached() {
          score += 1;
          scoreElement.textContent = score;
          player.row = playerStart.row;
          player.col = playerStart.col;
          movers.forEach(function (mover) {
            mover.speed *= 1.03;
          });
          updateBestScore();
        }

        function updateBestScore() {
          if (score > bestScore) {
            bestScore = score;
            bestScoreElement.textContent = bestScore;
            localStorage.setItem("acvBestScore", bestScore);
          }
        }

        function checkCollisions() {
          for (var i = 0; i < movers.length; i += 1) {
            var mover = movers[i];
            if (mover.row !== player.row) {
              continue;
            }
            var playerX = player.col * TILE_SIZE + TILE_SIZE / 2;
            var moverLeft = mover.x;
            var moverRight = mover.x + mover.width;
            var playerLeft = playerX - TILE_SIZE * 0.35;
            var playerRight = playerX + TILE_SIZE * 0.35;
            if (playerRight > moverLeft && playerLeft < moverRight) {
              triggerGameOver();
              break;
            }
          }
        }

        function triggerGameOver() {
          isGameOver = true;
          updateBestScore();
        }

        function restartGame() {
          isGameOver = false;
          score = 0;
          scoreElement.textContent = score;
          player.row = playerStart.row;
          player.col = playerStart.col;
          movers.forEach(function (mover) {
            mover.speed = mover.baseSpeed;
          });
        }

        function drawScene() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawLanes();
          drawMovers();
          drawPlayer();
          if (isGameOver) {
            drawGameOverOverlay();
          }
        }

        function drawLanes() {
          for (var row = 0; row < ROWS; row += 1) {
            var y = row * TILE_SIZE;
            var baseColor = "#d8f3dc";
            if (row === 0) {
              baseColor = "#b7e4c7";
            } else if (row === 1 || row === 2) {
              baseColor = "#a2d2ff";
            } else if (row >= 4 && row <= 6) {
              baseColor = "#6d6875";
            } else if (row === 3 || row === 7) {
              baseColor = "#cfe1b9";
            }
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, y, canvas.width, TILE_SIZE);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.25)";
            ctx.strokeRect(0, y, canvas.width, TILE_SIZE);
          }
        }

        function drawMovers() {
          movers.forEach(function (mover) {
            var y = mover.row * TILE_SIZE + TILE_SIZE * 0.15;
            var height = TILE_SIZE * 0.7;
            ctx.fillStyle = mover.color;
            ctx.fillRect(mover.x, y, mover.width, height);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
            ctx.strokeRect(mover.x, y, mover.width, height);
          });
        }

        function drawPlayer() {
          var x = player.col * TILE_SIZE + TILE_SIZE / 2;
          var y = player.row * TILE_SIZE + TILE_SIZE / 2;
          ctx.fillStyle = "#ffe66d";
          ctx.beginPath();
          ctx.arc(x, y, TILE_SIZE * 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#1d3557";
          ctx.beginPath();
          ctx.arc(x - 6, y - 5, 3, 0, Math.PI * 2);
          ctx.arc(x + 6, y - 5, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        function drawGameOverOverlay() {
          ctx.fillStyle = "rgba(0, 0, 0, 0.45)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#fff";
          ctx.font = "600 20px 'Segoe UI', sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("You were caught!", canvas.width / 2, canvas.height / 2 - 10);
          ctx.font = "16px 'Segoe UI', sans-serif";
          ctx.fillText("Press Space to try again", canvas.width / 2, canvas.height / 2 + 16);
        }
      })();
    </script>
  </body>
</html>
